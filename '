use crate::page::ColumnType;

pub fn read_varint(bytes: &[u8]) -> (i64, u8) {
    let mut trimmed_bytes: Vec<u8> = Vec::new();
    let mut continue_bit = true;
    for byte in bytes {
        if !continue_bit {
            break;
        }
        continue_bit = (byte & 0b1000_0000) == 0b1000_0000;

        let trimmed_byte = byte & 0b0111_1111;
        trimmed_bytes.push(trimmed_byte);
    }

    //for b in trimmed_bytes.iter() {
    //    println!("{:#010b}", b)
    //}

    let mut res = 0_i64;
    for byte in &trimmed_bytes {
        res |= *byte as i64;
        println!("after or {:#010b}", res);
        res <<= 7;
        println!("after shift {:#010b}", res);
    }

    (res, trimmed_bytes.len().try_into().unwrap())

    //let mut result: u64 = 0;
    //for (i, byte) in bytes.iter().enumerate() {
    //    let new_byte = if i == 8 { byte } else { &(byte & 0b0111_1111) };
    //    if i == 8 {
    //        result <<= 1;
    //    }
    //    result |= *new_byte as u64;
    //    if byte & 0b1000_0000 == 0 || i == 8 {
    //        if result == 5796848 {
    //            dbg!(bytes);
    //        }
    //        return (result.try_into().unwrap(), i as u8 + 1);
    //    }
    //    result <<= 7;
    //}
    //
    //todo!()
}

pub fn get_content_size_type(input: i64) -> (u64, ColumnType) {
    if input == 0 {
        return (0, ColumnType::Null);
    }

    if input == 1 {
        return (1, ColumnType::I8);
    }

    if input == 2 {
        return (2, ColumnType::I16);
    }

    if input == 3 {
        return (3, ColumnType::I24);
    }

    if input == 9 {
        return (0, ColumnType::One);
    }

    //if input >= 12 && input % 2 == 0 {
    //    return (((input - 12) / 2).try_into().unwrap(), ColumnType::Blob);
    //}

    if input >= 13 && input % 2 == 1 {
        return (((input - 13) / 2).try_into().unwrap(), ColumnType::Str);
    }

    todo!("column type {input}")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        //let (result, n) = read_varint(&[0x81, 0x47]);
        //assert_eq!(result, 199);
        //assert_eq!(n, 2);

        let (result, n) = read_varint(&[0x17]);
        assert_eq!(result, 23);
        assert_eq!(n, 1);

        //let bytes = [
        //    0b1000_0010,
        //    0b1110_0001,
        //    0b1110_0111,
        //    0b0111_0000,
        //    0b0000_1011,
        //    0,
        //    29,
        //    37,
        //    0,
        //];
        //
        //let (result, n) = read_varint(&bytes);
        //assert_eq!(result, 5796848);
        //assert_eq!(n, 4);
    }
}
